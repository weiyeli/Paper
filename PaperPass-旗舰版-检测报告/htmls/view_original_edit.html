<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="">
    <meta name="description" content="">
    <title>修改文档</title>
    <link href="css/bootstrap.css" rel="stylesheet" />
    <link href="css/style.css" rel="stylesheet" />
</head>
<body>
<div class="bg-grey PLR40">

    <div class="paper-txt P30 PB0">
        <div class="alert alert-success" role="alert">此为您在“详细报告”中修改后临时保存的内容，编辑过的内容会变绿色</div>
        <p class="text-idt25" data-id="1">基于患者E-Health诊治数据的安全存储与管理</p><p class="text-idt25" data-id="2">摘要</p><p class="text-idt25" data-id="3">着眼于传统电子医疗信息系统中存在的医疗数据的安全存储和授权共享的问题，本文提出了一个利用区块链特性设计的电子病历安全存储方案，还提出了一个利用智能合约实现的授权共享算法，该方案和算法有效地解决了安全存储和医疗数据“信息孤岛”的问题。此外，编码设计了一个基于 iOS平台和以太坊平台的医疗助手 App，该系统前端通过 iOS平台实现了问诊和就诊的流程，后台通过以太坊平台来存储患者的电子病历信息和管理电子病历的访问控制权限。经过编码实践，该系统能有效地实现本文提出的安全存储解决方案和授权共享算法。</p><p class="text-idt25" data-id="4">关键词：安全存储；授权共享；以太坊；电子病历；</p><p class="text-idt25" data-id="5">Secure storage and management based on patient E-Health diagnosis and treatment data</p><p class="text-idt25" data-id="6">Abstract</p><p class="text-idt25" data-id="7"> Focusing on the problem of secure storage and authorization sharing of medical data in traditional electronic medical information systems， this paper proposes an electronic medical record secure storage scheme based on blockchain characteristics， and proposes an authorization sharing algorithm using smart contracts. The program and algorithm effectively solve the problem of ”information islands” for secure storage and medical data. In addition， the code design has a medical assistant App based on the iOS platform and the Ethereum platform. The front end of the system realizes the process of consultation and treatment through the iOS platform， and the backstage stores the patient’ s electronic medical record information and manages the electronic medical record through the Ethereum platform. Access control permissions. After coding practice， the system can effectively implement the secure storage solution and authorization sharing algorithm proposed in this paper.</p><p class="text-idt25" data-id="8">Keywords：Secure storage; authorized sharing; Ethereum; electronic medical record;</p><p class="text-idt25" data-id="9">目录</p><p class="text-idt25" data-id="10">1.绪 论5</p><p class="text-idt25" data-id="11">1.1研究背景、目的与意义5</p><p class="text-idt25" data-id="12">1.2国内外研究现状5</p><p class="text-idt25" data-id="13">1.3论文内容与组织6</p><p class="text-idt25" data-id="14">2.本论文相关理论6</p><p class="text-idt25" data-id="15">2.1区块链技术6</p><p class="text-idt25" data-id="16">2.1.1定义6</p><p class="text-idt25" data-id="17">2.1.2区块链体系架构7</p><p class="text-idt25" data-id="18">2.1.3区块链的应用场景7</p><p class="text-idt25" data-id="19">2.1.4工作原理8</p><p class="text-idt25" data-id="20">2.1.5共识机制9</p><p class="text-idt25" data-id="21">2.1.6区块链的类型10</p><p class="text-idt25" data-id="22">2.1.7 区块链的优点11</p><p class="text-idt25" data-id="23">2.2智能合约11</p><p class="text-idt25" data-id="24">2.3以太坊12</p><p class="text-idt25" data-id="25">2.3.1 以太坊运作机制12</p><p class="text-idt25" data-id="26">2.3.2以太坊账户13</p><p class="text-idt25" data-id="27">3. 基于区块链的电子病历安全存储和授权共享方案14</p><p class="text-idt25" data-id="28">3.1研究目标和研究内容14</p><p class="text-idt25" data-id="29">3.1.1 基于区块链的电子病历存储系统15</p><p class="text-idt25" data-id="30">3.1.2 基于智能合约的授权共享算法16</p><p class="text-idt25" data-id="31">3.2拟解决的关键科学问题17</p><p class="text-idt25" data-id="32">4.基于以太坊的电子病历安全存储和授权共享的验证实现17</p><p class="text-idt25" data-id="33">4.1系统框架设计17</p><p class="text-idt25" data-id="34">4.2 核心代码实现19</p><p class="text-idt25" data-id="35">4.2.1 智能合约Solidity源码19</p><p class="text-idt25" data-id="36">4.2.2iOS客户端核心源码21</p><p class="text-idt25" data-id="37">4.3运行环境25</p><p class="text-idt25" data-id="38">4.4开发技术25</p><p class="text-idt25" data-id="39">4.4.1 Solidity26</p><p class="text-idt25" data-id="40">4.4.2 Swift26</p><p class="text-idt25" data-id="41">4.4.3 Ganache26</p><p class="text-idt25" data-id="42">4.4.4 Web3.js26</p><p class="text-idt25" data-id="43">4.6系统演示27</p><p class="text-idt25" data-id="44">4.6.1 启动Node.js服务器28</p><p class="text-idt25" data-id="45">4.6.2 启动Mongodb数据库28</p><p class="text-idt25" data-id="46">4.5.1 登录/注册31</p><p class="text-idt25" data-id="47">4.5.3 患者查看历史病历34</p><p class="text-idt25" data-id="48">4.5.4 病历详情35</p><p class="text-idt25" data-id="49">4.5.4 预约挂号36</p><p class="text-idt25" data-id="50">4.5.5 医生问诊38</p><p class="text-idt25" data-id="51">4.5.6 新建病历40</p><p class="text-idt25" data-id="52">5.问题与解决办法43</p><p class="text-idt25" data-id="53">5.1遇到的问题43</p><p class="text-idt25" data-id="54">5.2解决办法44</p><p class="text-idt25" data-id="55">5.3开发技巧44</p><p class="text-idt25" data-id="56">6.总结与展望44</p><p class="text-idt25" data-id="57">6.1总结44</p><p class="text-idt25" data-id="58">6.2展望45</p><p class="text-idt25" data-id="59">6.3致谢45</p><p class="text-idt25" data-id="60">1.绪论</p><p class="text-idt25" data-id="61">1.1研究背景、目的与意义</p><p class="text-idt25" data-id="62">医疗健康问题与每一个人都息息相关，患者的医疗记录（包括病历、化验单、 CT图等）都是患者个人健康状况的有效证明，对于患者了解自身健康状态和调养十分重要[1]。然而我国的医疗发展起步晚，医疗设施落后，医疗信息化和数字化进程缓慢，对于病人的医疗隐私数据也缺乏安全有效的管理。医疗信息数字化是未来的发展趋势，利用现代先进的计算机技术，可以减少传统医疗系统中重复的人力操作，使得诊治过程规范化。其中医疗数据（处方、病历记录、身份信息、文档信息）的安全存储和管理更是重中之重，如何安全有效地解决医疗数据的存储和管理是本文的重点。</p><p class="text-idt25" data-id="63">此外，当前时代是大数据时代，数据的作用被极大的释放，医疗数据更是数据分析的宝贵来源。在传统的医疗信息系统中，由于信息缺乏安全存储，信息容易被不法分子利用，进行贩卖。同时，由于各种医疗机构之间的不信任，医疗数据的共享更是困难，逐渐的形成了”数据孤岛”。数据的不流通导致了协同诊治平台的推进困难，患者往返于各种医院和医疗机构，无法综合各个机构的诊治结果形成完善的就诊报告。</p><p class="text-idt25" data-id="64">综上所述，设计一套可以独立于第三方医疗机构，对患者个人的医疗数据进行安全存储，同时可以由患者授权给第三方读取，方便不同的医院和医疗机构进行协同诊治的系统十分必要。</p><p class="text-idt25" data-id="65">1.2国内外研究现状</p><p class="text-idt25" data-id="66">21世纪是信息化时代，个人数据被大量收集和利用，医疗数据也不例外。对医疗数据的挖掘和分析，有利于医疗机构进行对于疾病的研究和防控，但同时也会带来隐私问题。隐私保护是针对公开发布的数据采取的一系列措施，防止第三方通过数据挖掘等不法手段获取病人的敏感信息。在数据发布领域，学者提出了多种隐私保护模型，主要包括：t-closeness、I-多样性、k-匿名模型等。这些模型的原理都是通过隐藏公开的隐私数据和具体个人之间的关系，但是保证发布数据的信息公开可用[2]。</p><p class="text-idt25" data-id="67">1.3论文内容与组织</p><p class="text-idt25" data-id="68">本文提出了一种基于区块链实现的电子病历存储方案，还提出了一个基于以太坊智能合约实现的授权共享算法。经过编码实现，验证了上述方案和算法的有效性和安全性。</p><p class="text-idt25" data-id="69">本文的主要内容共分为六章。</p><p class="text-idt25" data-id="70">第一章，绪论，介绍了医疗数据在当今社会的重要性，分析了医疗隐私数据存储和共享的难点，对比了国内外关于隐私数据存储算法的发展和趋势。</p><p class="text-idt25" data-id="71">第二章，介绍本文提出的方案和算法中涉及到的核心技术相关的理论基础，主要包括：区块链技术、比特币技术、以太坊平台等。</p><p class="text-idt25" data-id="72">第三章，提出基于以太坊平台的电子病历存储和授权共享方案，详细讨论了系统的整体框架和所用技术，经过编程验证得出实验结果。</p><p class="text-idt25" data-id="73">第四章，详细描述了系统的验证实现，对系统中相关核心源码进行解释，最后展示最终的系统界面和功能实现。</p><p class="text-idt25" data-id="74">第五章，主要讨论了系统设计开发过程中遇到的困难和解决办法。</p><p class="text-idt25" data-id="75">第六章，总结和展望。</p><p class="text-idt25" data-id="76">2.本论文相关理论</p><p class="text-idt25" data-id="77">2.1区块链技术</p><p class="text-idt25" data-id="78">2.1.1定义</p><p class="text-idt25" data-id="79">本文提出的方案和设计的系统以近年来火热的区块链技术为核心。区块链技术的由来源自2008年，中本聪在《Bitcoin：A peer-to-peer Electronic Cash System》一文中首次提出了“区块链”的概念。但是该文着重描写比特币系统，对于区块链技术并没有给出具体的定义。在中本聪的论文中，区块和链被描述为一种用于记录比特币交易过程中交易历史的数据结构。维基百科对于区块链的定义是：区块链（英语：blockchain或block chain）是一串连接起来的加密过的交易记录，每一个记录被称为一个区块。每一个区块包含了前一个区块的hash值、对应时间的时间戳以及交易记录，上述特点使得区块内容具不可篡改性。本文认为区块链既是一种数据结构，又可以认为是分布式数据库，从广义上看它也代指一系列分布式记账技术，包括智能合约、共识机制等。</p><p class="text-idt25" data-id="80">2.1.2区块链体系架构</p><p class="text-idt25" data-id="81">区块链平台自底向上可以分为数据层、网络层、共识层、合约层、应用层五个层次[3]。数据层采用默克尔树、交易结构、签名结构等数据结构与数据库对区块、交易进行存储；网络层采用P2P协议完成各个节点间的数据传输；共识层通过对应的算法和激励机制，解决了拜占庭容错和分布式一致性问题；合约层通过编写智能合约，让开发者再合约上可以进行交易；应用层提供公开的API接口，允许用户创建和运行智能合约。</p><p class="text-idt25" data-id="82">/</p><p class="text-idt25" data-id="83">图1 区块链体系架构</p><p class="text-idt25" data-id="84">2.1.3区块链的应用场景</p><p class="text-idt25" data-id="85">根据区块链的设计技术，区块链系统具有分布式高冗余存储、不可篡改、去中心化、自动执行的智能合约等特点。区块链不仅可以应用在金融领域，在医疗、社会系统中也有着巨大的应用潜力。区块链目前的应用场景主要有以下几方面：数字货币、数据存储、数据鉴证、金融交易、资产管理和投票选举六大场景[7]。</p><p class="text-idt25" data-id="86">2.1.4工作原理</p><p class="text-idt25" data-id="87">传统的金融交易系统，都需要可信赖的第三方金融机构作为担保，实践证明这种机制一直运转良好，但是这类系统天生存在着以信任作为基石的的弱点。传统的交易系统并不能实现完全不可逆的交易，因为现实中存在的第三方机构不能保证不会发生分歧。另一方面，第三方金融机构的存在，一定程度上增加了交易的复杂性。所以，人们需要一种新型的电子交易系统，基于密码学技术而以信用为基础。买家和卖家达成共识后可以直接进行交易，交易过程不需要第三方金融机构的参与，并且产生的交易是不可逆的。</p><p class="text-idt25" data-id="88">/</p><p class="text-idt25" data-id="89">图2 基于数字签名的电子货币</p><p class="text-idt25" data-id="90">区块链或者说比特币的出现解决了上述难题，中本聪的论文中提出了一种完全通过peer-to-peer技术实现的电子现金交易系统。一般的电子交易系统无法解决”双重支付”的难题。所谓”双重支付”指的是同一枚电子货币被支付两次，为了解决”双重支付”的问题我们又要引入第三方机构来作为公证，这无疑不符合去中心化的特点。因此中本聪提出了一种解决方案，该系统通过随机散列对全部交易记录加上时间戳，将他们加入到一个不断延伸的基于 hash值的工作量证明的链条作为交易记录，除非重新完成所有的工作量证明，否则这条链条被认为是不可更改的。只要互联网中大多数的计算能力没有合起来对系统发起攻击，那么可以认为这条链条是安全的[5]。</p><p class="text-idt25" data-id="91">2.1.5共识机制</p><p class="text-idt25" data-id="92">共识机制常见于区块链领域中，即多个节点如何达成共识的机制。由于区块链去中心化的特点，区块链中的各个节点是分布式的。要维护系统的运作顺序和公平性，必须设计一套算法，来统一调度和提供激励机制和惩罚机制。这样的制度，必须依赖某种方式来证明，由哪个节点获得记账权，并且可以获取记录这一个区块的奖励；或者惩罚攻击诚实节点的攻击者。这就是共识机制。常见的共识机制有以下几种：</p><p class="text-idt25" data-id="93">1.工作量证明（Proof-of-Work，PoW），典型案例：比特币网络</p><p class="text-idt25" data-id="94">2.权益证明（Proof-of-Stake，PoS，又译持有量证明），典型案例：以太坊</p><p class="text-idt25" data-id="95">3.股份授权证明（Delegated-Proof-of-Stake，DPoS），典型案例：EOS</p><p class="text-idt25" data-id="96">4.容量证明（Proof-of-space，PoSpace，又称 Proof-of-Capacity，PoC）</p><p class="text-idt25" data-id="97">本文主要讨论工作量证明机制：</p><p class="text-idt25" data-id="98">工作量证明（Proof-of-work）是比特币和以太坊等货币中最常用的算法，其核心依赖于密码学。在分析工作量证明算法前先介绍散列函数（哈希函数）的概念。散列函数是一种函数映射关系，可以将任何长度的数据映射到同一大小的数据。以MD5算法举例如下：</p><p class="text-idt25" data-id="99">MD5(“Hello World”) = B10A8DB164E0754105B7A99BE72E3FE5</p><p class="text-idt25" data-id="100">MD5(“Hello World!”) = RNG76287532E96365E841E92BFC50EDG</p><p class="text-idt25" data-id="101">由上述结果可见，原文细小的改变都会导致随机散列值巨大的变化。</p><p class="text-idt25" data-id="102">工作量证明算法中，区块链通过共识算法来推选一位Leader来记录下一个区块的内容。Leader还要负责把该区块广播到外界网络，方便其他节点检验该区块的有效性。对该问题简单叙述如下：给定数据X，找到一个数n，使得X+n得到的哈希值是一个小于Y的数。举例如下：</p><p class="text-idt25" data-id="103">Y = 10，X = “Hello World!”</p><p class="text-idt25" data-id="104">hash(X) = hash(“Hello World”) = 0x0f = 15 ＞ 10</p><p class="text-idt25" data-id="105">hash(x+1) = hash(“Hello World1”) = 0xff = 255 ＞ 10</p><p class="text-idt25" data-id="106">hash(x+2) = hash(“Hello World2”) = 0x09 = 9 ＜ 10</p><p class="text-idt25" data-id="107">因此，找到n为2满足要求。由于MD5函数式加密安全的，所以我们通过暴力求解来尝试所有的组合。我们把最快计算出上述结果的成员称为矿工，每一个区块被开发的时候，矿工会获得一部分奖励。</p><p class="text-idt25" data-id="108">另一方面，工作量证明解决了确定最长的链条作为可信任的区块链的问题，因为最长的链条被认为是安全的。如果有攻击者想要对现在的区块进行篡改，那么攻击者需要完成当前区块之前的所有工作量，并最终超越现有的区块的工作量。经过证明，攻击者想要追赶上现有的区块，其成功概率呈指数化递减。但是，这不意味着区块链系统是绝对安全的。根据摩尔定律，硬件的运算速度在高速增加，而且诚实节点参与的网络状况也会有所变化。为了解决这种不安全的因素，工作量证明将难度与区块的生成速度的平均值相关联，如果区块生成的速度过快，那么难度将会提高。</p><p class="text-idt25" data-id="109">2.1.6区块链的类型</p><p class="text-idt25" data-id="110">区块链技术根据实际应用场景和需求具有公有链、联盟链和私有链三种应用模式[4]。</p><p class="text-idt25" data-id="111">他们的特点如下：</p><p class="text-idt25" data-id="112">1.公有链。公有链允许任何人自由进出，共识机制采用 pow/ pos/ Dpos，需要所有人参与记账，需要激励机制，完全去中心化，每秒可以承载最多100笔交易，典型应用场景是加密货币，代表项目为：比特币、以太坊和EOS。</p><p class="text-idt25" data-id="113">2.联盟链。联盟链只允许联盟成员参与，共识机制采用分布式一致性算法，记账人由联盟成员协商确定，激励机制可选，弱中心化，每秒可承载最多10万笔交易，典型应用场景包括供应链金融、银行、物流、电商等，代表项目有 R3、 Hyperledger。</p><p class="text-idt25" data-id="114">3.私有链。私有链只允许链的所有者，共识机制为 solo/ pbft等，记账人为链的所有者，不需要激励机制，强中心化，承载能力视配置而定，典型场景包括大型组织、机构。</p><p class="text-idt25" data-id="115">/</p><p class="text-idt25" data-id="116">图3区块链的三种类型</p><p class="text-idt25" data-id="117">2.1.7 区块链的优点</p><p class="text-idt25" data-id="118">区块链是一种多方共同维护的分布式数据库[9]，与传统数据库系统相比，其主要优势如下:</p><p class="text-idt25" data-id="119">去中心化。传统的数据库系统包括关系型数据库、NoSQL等非关系型都需要由某个机构单独进行管理。区块链去中心化的设计是由多节点管理，每个节点都存储了一份完整的数据。</p><p class="text-idt25" data-id="120">不可篡改。区块链利用Merkle树这种数据结构实现了区块链上数据的不可篡改的特性。</p><p class="text-idt25" data-id="121">可追溯。区块链系统中的每一个节点都存储了自系统运行以来所有的交易数据，由于数据的不可篡改性，可以方便地还原出所有的交易信息。</p><p class="text-idt25" data-id="122">高可信。区块链的参与者不需要互相信用，每一笔交易需要发送者通过数字签名验证身份，并且需要大多数的节点达成共识才可以写到链上，交易一旦写入，不允许被篡改，除非攻击者完成之前的所有工作量。</p><p class="text-idt25" data-id="123">高可用。传统数据库通过配置主数据库和从数据库并且保证主备一致来达到高可用，但是这种方式代价高昂。区块链中每一个节点都是主数据库，某一个节点故障不会影响整个网络的运行。</p><p class="text-idt25" data-id="124">2.2智能合约</p><p class="text-idt25" data-id="125">智能合约( smart contract)是一种特殊协议，在区块链内制定合约时使用，当中内含了函数( Function)，也能与其他合约进行互动、做决策、存储资料以及传送以太币等功能。智能合约主要提供验证及执行合约内所订立的条件。</p><p class="text-idt25" data-id="126">智能合约的概念最早于1994年由从事智能合约和数字货币研究的尼克萨博(Nick Szabo)博士提出，是与互联网同一时期的产物。当时因为智能合约没有可信的执行环境，智能合约只是一种理论，并没有被技术落地。/</p><p class="text-idt25" data-id="127">图4 区块链上的智能合约模型结构</p><p class="text-idt25" data-id="128">2.3以太坊</p><p class="text-idt25" data-id="129">本文设计的电子医疗系统利用了以太坊平台，在已有的平台基础上开发设计了一套智能合约。以太坊（英语：Ethereum）最初由 Vitalik Buterin 在2013年提出，是一个开源的具有智能合约功能的公共区块链平台。以太坊通过其专用加密货币以太币(英语：Ether)提供去中心化的虚拟机来处理点对点合约。以太坊创建的目的是创建一个可自我执行、抗审查和可以自我维护的去中心化的世界级计算机。它延伸了比特币的区块链概念：在分布式的计算机上存储、交易和验证数据。以太坊（Ethereum）在比特币的概念上作出了更加巨大的创新，使在被互联网连接的多个计算机上运行代码成为现实。可以简单的理解：比特币的基础区块链上面存储的是交易记录，而以太坊的基础区块链上存储的是一段可运行的程序代码。以太坊的目的是让用户可以通过支付以太币来使用大量的节点进行计算和存储的功能。</p><p class="text-idt25" data-id="130">2.3.1 以太坊运作机制</p><p class="text-idt25" data-id="131">以太坊和区块链一样需要大量的节点在各自的计算机上运行，来保证系统的运作。以太坊虚拟机（ EVM）需要被安装在每一个节点上，由每一个节点运行， EVM在某种程度上 EVM相当于操作系统，它可以解释 Solidity语言，将 Solidity语言转换成字节码，让 Solidity语言编写的智能合约代码可以运行在各个节点上。和区块链相同，在以太坊上执行智能合约需要支付以太币。以太坊上执行的智能合约记录了在区块上执行的交易的信息，以太坊区块链上的交易如下：</p><p class="text-idt25" data-id="132">/</p><p class="text-idt25" data-id="133">图5以太坊区块链上的交易</p><p class="text-idt25" data-id="134"> Timestamp指的是每一个区块的时间戳， Sender代表这个区块的发起者， Recipient代表交易的收货方， Amount代表交易的数额， Data用于创建记录和执行智能合约。</p><p class="text-idt25" data-id="135">以太坊区块链可以包含以下三种交易方式：</p><p class="text-idt25" data-id="136">人与人之间的以太币转账。类似于比特币交易，“Data”为空。</p><p class="text-idt25" data-id="137">无接收方的以太币转账。进行无接收方的交易时，数据项里面存储的是新建的智能合约代码。</p><p class="text-idt25" data-id="138">用户与智能合约之间的以太币转账。Recipient设置为智能合约的地址，执行的指令存储在Data项中。</p><p class="text-idt25" data-id="139">2.3.2以太坊账户</p><p class="text-idt25" data-id="140">以太坊的账户主要包括计数器、以太币余额和智能合约代码。</p><p class="text-idt25" data-id="141">两个账户之间的交易信息和信息的状态转换构成了以太坊系统的”状态”。以太币(Ether)是以太坊里面的加密用度，主要用来支出交易用度。以太坊有两种类型账户：合约账户CA（Contracts Accounts）和外部账户EOA（Externally Owned Accounts）。</p><p class="text-idt25" data-id="142">合约账户是智能合约代码用的账户，外部账户是人用的账户；所以合约账户可以存储并执行智能合约代码，它的”智能性”被外部账户激活。合约账户不存储和存储私钥，合约账户还可以调用其他合约。</p><p class="text-idt25" data-id="143">外部账户是由使用以太坊的人直接使用的账户，可以存储以太币，可以发送交易到合约账户，触发既定的代码逻辑。外部账户由公钥标识，由对应的私钥控制。</p><p class="text-idt25" data-id="144">当合约账户被调用时，存储在其中的智能合约可以在矿工处的虚拟机中自动执行，并消耗 Gas，如果 Gas不足则会触发” Out of Gas”异常，被终止执行。无论是合约账户还是外部账户，在以太坊内部都被看做状态对象。其中合约账户存储了余额和代码，外部账户存储了以太币的余额。</p><p class="text-idt25" data-id="145">3.基于区块链的电子病历安全存储和授权共享方案</p><p class="text-idt25" data-id="146">3.1研究目标和研究内容</p><p class="text-idt25" data-id="147">本系统是对原慢病移动监护协同诊治平台的子系统进行升级。“慢病移动监护协同诊治平台”(简称：“慢病家居监护平台”)，该开发平台通过 APP端的手机移动模式，提供直观、方便、快捷的家居移动医疗监护数据的实时采集、上传云服务器，原有平台的功能组成图如下所示：</p><p class="text-idt25" data-id="148">/</p><p class="text-idt25" data-id="149">图6平台功能组成图</p><p class="text-idt25" data-id="150">本系统主要对原医疗协同平台系统中的电子病历管理和权限管理两个模块进行改造升级。</p><p class="text-idt25" data-id="151">/</p><p class="text-idt25" data-id="152">图7原平台模块调用关系图</p><p class="text-idt25" data-id="153">原有平台的用户数据、医疗信息数据都存储在医院的关系型数据库中，由医院统一进行管理。现代医疗的一大难题就是数据的获取，高昂的数据成本和患者对于隐私的谨慎使得获得医疗数据十分困难。在传统的医疗信息系统中，患者的医疗信息都由医院统一管理，患者的访问权限十分有限。</p><p class="text-idt25" data-id="154">3.1.1 基于区块链的电子病历存储系统</p><p class="text-idt25" data-id="155">针对上述问题，本文提出了一种基于区块链的电子病历存储方案，该方案采用以太坊为跨医疗机构的医疗数据创建去中心化的病历管理系统。该系统可以为用户提供一个全新的、去中心化的病历管理方案，使用区块链来保存管理电子病历。所有存储在这个系统的记录有以下特点：</p><p class="text-idt25" data-id="156">1.患者可以自行管理自己的病历不需要依赖于第三方机构。</p><p class="text-idt25" data-id="157">2.患者可以将自己病历的权限赋予医院，医院的医生获得权限后可以查看和编辑患者的病历。</p><p class="text-idt25" data-id="158">3.利用独特的区块链属性，以及内含的加密模块，能够在处理敏感信息时为用户提供强大的保密技术。</p><p class="text-idt25" data-id="159">3.1.2 基于智能合约的授权共享算法</p><p class="text-idt25" data-id="160">在传统的医疗系统中，存在医疗记录授权流程繁琐、记录分享效率低下和身份验证困难等问题[10]。区块链技术与密码学技术相结合，可以简化传统的身份验证过程，同时保证较高的安全性。本文提出了一种利用以太坊智能合约实现的身份验证算法，通过 Solidity编程语言本身的特性可以很好的实现鉴权的过程，同时利用以太坊区块链不可篡改的特性保证了用户医疗信息隐私。</p><p class="text-idt25" data-id="161">在以太坊中，智能合约本质上是一段计算机程序，它可以自动执行，通常用Solidity编程语言来编码实现，运行在EVM虚拟机上[8]。智能合约也可以被看做是一组函数，每一个函数对应着一系列的字节码，它可以像函数一样接受参数，并对接收到的参数进行回应。</p><p class="text-idt25" data-id="162">在Solidity语言中，modifier是很重要的一个关键字。通过modifier 可以更便捷的校验函数的入参。如果能够合理的利用modifier去检验发送者的地址，那么就可以实现权限控制的功能。授权的功能可以通过增加一个 checker对象，在合约初始化时，判断发送者的地址是否是合约所属者或者是添加的 checker对象，如果是则可以通过合约拿到病历数据，反之返回错误。算法的Solidity伪代码如下：</p><p class="text-idt25" data-id="163">modifier check() {</p><p class="text-idt25" data-id="164">require(</p><p class="text-idt25" data-id="165">msg.sender == owner   msg.sender == checker，</p><p class="text-idt25" data-id="166">”Only ath-person can do this ops.”</p><p class="text-idt25" data-id="167">);</p><p class="text-idt25" data-id="168">_;</p><p class="text-idt25" data-id="169">}</p><p class="text-idt25" data-id="170">3.2拟解决的关键科学问题</p><p class="text-idt25" data-id="171">设计一套模拟患者就诊和医生问诊的在线医疗系统，该系统应该具有以下功能：</p><p class="text-idt25" data-id="172">患者/医生的登录/注册功能</p><p class="text-idt25" data-id="173">患者预约挂号</p><p class="text-idt25" data-id="174">患者查看自己的过往病历</p><p class="text-idt25" data-id="175">医生问诊（包括：查询患者过往病历、撰写诊断结果）</p><p class="text-idt25" data-id="176">此外，还需要搭建本地私有链环境。使用以太坊作为区块链平台，需要解决以太坊的配置，还需要编写一套智能合约，用来接收患者和医生的请求和实现数据的存储与读取。</p><p class="text-idt25" data-id="177">4.基于以太坊的电子病历安全存储和授权共享的验证实现</p><p class="text-idt25" data-id="178">该部分针对上一章节提出的基于区块链的存储方案和授权共享算法进行编码实现。系统前端利用iOS平台开发医疗助手App，模拟了患者就诊和预约挂号的流程和医生问诊、查看患者病历和撰写病历的流程。系统后台基于NodeJS、MongoDB、Ganache搭建了一套利用以太坊区块链存储的后台框架，实现了数据库和区块链联合存储并对外暴露访问API的功能。下文将从系统的框架设计、核心代码实现和界面演示三方面进行详细的讲解。</p><p class="text-idt25" data-id="179">4.1系统框架设计</p><p class="text-idt25" data-id="180">系统框架图如下：</p><p class="text-idt25" data-id="181">/</p><p class="text-idt25" data-id="182">图 9 系统整体框架图</p><p class="text-idt25" data-id="183">系统流程图如下：</p><p class="text-idt25" data-id="184">/</p><p class="text-idt25" data-id="185">图8系统流程图</p><p class="text-idt25" data-id="186">客户端采用了iOS平台，设计了一款医疗助手App。患者和医生都可以通过 App注册和登录到系统，其中患者登录后可以查看自己的历史病历信息还可以预约挂号，患者预约某个医院相当于将自己的病历的访问控制权限授权给该医院的医生。该医院的医生拿到患者的授权后，可以查看到患者的历史病历信息。医生诊治后，可以在App上给患者新建病历，录入诊治内容，新建的病历会写入到以太坊的区块链中。</p><p class="text-idt25" data-id="187">4.2 核心代码实现</p><p class="text-idt25" data-id="188">4.2.1 智能合约Solidity源码</p><p class="text-idt25" data-id="189">pragma solidity ^0.5.0;</p><p class="text-idt25" data-id="190">contract Ehealth {</p><p class="text-idt25" data-id="191">//</p><p class="text-idt25" data-id="192">address payable public patient;</p><p class="text-idt25" data-id="193">string name;</p><p class="text-idt25" data-id="194">string record;</p><p class="text-idt25" data-id="195">string gender;</p><p class="text-idt25" data-id="196">address myaddress;</p><p class="text-idt25" data-id="197">address checker;</p><p class="text-idt25" data-id="198">uint age;</p><p class="text-idt25" data-id="199">constructor(string memory _name， string memory _gender， uint _age) public {</p><p class="text-idt25" data-id="200">name = _name;</p><p class="text-idt25" data-id="201">gender = _gender;</p><p class="text-idt25" data-id="202">age = _age;</p><p class="text-idt25" data-id="203">myaddress  = msg.sender;</p><p class="text-idt25" data-id="204">checker = msg.sender;</p><p class="text-idt25" data-id="205">}</p><p class="text-idt25" data-id="206">modifier check() {</p><p class="text-idt25" data-id="207">require(</p><p class="text-idt25" data-id="208">msg.sender == myaddress    msg.sender == checker，</p><p class="text-idt25" data-id="209">”Only ath-person can do this ops.”</p><p class="text-idt25" data-id="210">);</p><p class="text-idt25" data-id="211">_;</p><p class="text-idt25" data-id="212">}</p><p class="text-idt25" data-id="213">modifier check_doc() {</p><p class="text-idt25" data-id="214">require(</p><p class="text-idt25" data-id="215">msg.sender == checker，</p><p class="text-idt25" data-id="216">”Only doc can do this ops.”</p><p class="text-idt25" data-id="217">);</p><p class="text-idt25" data-id="218">_;</p><p class="text-idt25" data-id="219">}</p><p class="text-idt25" data-id="220">event makeChange(address _a);</p><p class="text-idt25" data-id="221">function authens(address _checker) public{</p><p class="text-idt25" data-id="222">checker = _checker;</p><p class="text-idt25" data-id="223">}</p><p class="text-idt25" data-id="224">function unAuth() public check{</p><p class="text-idt25" data-id="225">checker = myaddress;</p><p class="text-idt25" data-id="226">}</p><p class="text-idt25" data-id="227">function getName() public view returns(string memory){</p><p class="text-idt25" data-id="228">return name;</p><p class="text-idt25" data-id="229">}</p><p class="text-idt25" data-id="230">function getRec() public view check returns(string memory，string memory，uint，string memory){</p><p class="text-idt25" data-id="231">return (name， gender， age，record);</p><p class="text-idt25" data-id="232">}</p><p class="text-idt25" data-id="233">function setRec(string memory _rec) public check{</p><p class="text-idt25" data-id="234">record = _rec;</p><p class="text-idt25" data-id="235">emit makeChange(msg.sender);// who changed it.</p><p class="text-idt25" data-id="236">}</p><p class="text-idt25" data-id="237">}</p><p class="text-idt25" data-id="238">智能合约是运行在以太坊上的一段代码，用户与智能合约提供的函数交互从而达到读取电子病历和存储电子病历的功能。address payable public patient; 存储了患者的账户，代表这份智能合约属于哪一位患者。合约中存储了患者的信息，包括姓名、年龄等。其中最为重要的是record和check两个变量，其中record存储的是病历的内容。前端App将病历的信息转换为json格式的字符串，存储在record中，每一份病历通过一定的标志进行分离。checker存储的是被授权的机构的地址，可以看做医院的凭证，其中checker对应的医院的医生有读取和写入record的权限。其中权限控制的代码在 modifier check()函数中， msg. sender== myaddress msg. sender== checker，这行代码保证了只有当发起人为患者或者是被授权的医院时，才可以访问智能合约中的数据，否则拒绝访问。</p><p class="text-idt25" data-id="239">iOS客户端核心源码</p><p class="text-idt25" data-id="240">import Foundation</p><p class="text-idt25" data-id="241">import Alamofire</p><p class="text-idt25" data-id="242">import SwiftyJSON</p><p class="text-idt25" data-id="243">class NetworkService {</p><p class="text-idt25" data-id="244">static let shared = NetworkService()</p><p class="text-idt25" data-id="245">// 用户注册</p><p class="text-idt25" data-id="246">func register(user: User) {</p><p class="text-idt25" data-id="247">DispatchQueue.global().async { [weak self] in</p><p class="text-idt25" data-id="248">AF.request(”http://localhost:5000/user/register”，</p><p class="text-idt25" data-id="249">method: .post，</p><p class="text-idt25" data-id="250">parameters: self?.encodeUser(user: user)).responseJSON { response in</p><p class="text-idt25" data-id="251">if let data = response.data， let utf8Text = String(data: data， encoding: .utf8) {</p><p class="text-idt25" data-id="252">print(”Data: \(utf8Text)”) // original server data as UTF8 string</p><p class="text-idt25" data-id="253">}</p><p class="text-idt25" data-id="254">}</p><p class="text-idt25" data-id="255">}</p><p class="text-idt25" data-id="256">}</p><p class="text-idt25" data-id="257">// 用户登录</p><p class="text-idt25" data-id="258">func login(userName: String， password: String) {</p><p class="text-idt25" data-id="259">DispatchQueue.global().async { [weak self] in</p><p class="text-idt25" data-id="260">AF.request(”http://localhost:5000/user/login”，</p><p class="text-idt25" data-id="261">method: .post，</p><p class="text-idt25" data-id="262">parameters: self?.encodeLoginMsg(userName: userName， password: password)).responseJSON { response in</p><p class="text-idt25" data-id="263">if let data = response.data {</p><p class="text-idt25" data-id="264">do {</p><p class="text-idt25" data-id="265">let res = try JSONSerialization.jsonObject(with: data， options: []) as! [String: Any]</p><p class="text-idt25" data-id="266">if let error = res[”errors”] {</p><p class="text-idt25" data-id="267">UserService.shared.isLogin = false</p><p class="text-idt25" data-id="268">print(error)</p><p class="text-idt25" data-id="269">} else {</p><p class="text-idt25" data-id="270">UserService.shared.isLogin = true</p><p class="text-idt25" data-id="271">// 保存用户的信息</p><p class="text-idt25" data-id="272">let user = User(name: res[”name”] as! String，</p><p class="text-idt25" data-id="273">phone: ””，</p><p class="text-idt25" data-id="274">userName: ””，</p><p class="text-idt25" data-id="275">password: ””，</p><p class="text-idt25" data-id="276">userType: res[”userType”] as! Int，</p><p class="text-idt25" data-id="277">isCreated: ””)</p><p class="text-idt25" data-id="278">UserService.shared.setLoginUser(user: user)</p><p class="text-idt25" data-id="279">}</p><p class="text-idt25" data-id="280">} catch let error as NSError {</p><p class="text-idt25" data-id="281">print(error)</p><p class="text-idt25" data-id="282">}</p><p class="text-idt25" data-id="283">}</p><p class="text-idt25" data-id="284">}</p><p class="text-idt25" data-id="285">}</p><p class="text-idt25" data-id="286">}</p><p class="text-idt25" data-id="287">// 获取医院信息</p><p class="text-idt25" data-id="288">func getHospitalMsg(completionHandler: @escaping (_ resArray: [[String: Any]]) -] Void) {</p><p class="text-idt25" data-id="289">DispatchQueue.global().async {</p><p class="text-idt25" data-id="290">AF.request(”http://localhost:5000/home/hospitals”，</p><p class="text-idt25" data-id="291">method: .get).responseJSON { response in</p><p class="text-idt25" data-id="292">if let data = response.data {</p><p class="text-idt25" data-id="293">do {</p><p class="text-idt25" data-id="294">if let hospitalDictionaryArray = try JSONSerialization.jsonObject(with: data， options: []) as? [[String: Any]] {</p><p class="text-idt25" data-id="295">// 把数据传输给VC</p><p class="text-idt25" data-id="296">completionHandler(hospitalDictionaryArray)</p><p class="text-idt25" data-id="297">}</p><p class="text-idt25" data-id="298">} catch let error as NSError {</p><p class="text-idt25" data-id="299">print(error)</p><p class="text-idt25" data-id="300">}</p><p class="text-idt25" data-id="301">}</p><p class="text-idt25" data-id="302">}</p><p class="text-idt25" data-id="303">}</p><p class="text-idt25" data-id="304">}</p><p class="text-idt25" data-id="305">// 预约挂号</p><p class="text-idt25" data-id="306">func authorization(hospitalName: String， completionHandler: @escaping (_ status: Int) -] Void) {</p><p class="text-idt25" data-id="307">DispatchQueue.global().async {</p><p class="text-idt25" data-id="308">let url = URL(string: ”http://localhost:5000/home/hospitals”)?.appendingPathComponent(hospitalName).appendingPathComponent(”reservation”)</p><p class="text-idt25" data-id="309">AF.request(url!.absoluteString，</p><p class="text-idt25" data-id="310">method: .post).responseJSON { response in</p><p class="text-idt25" data-id="311">if let data = response.data， let utf8Text = String(data: data， encoding: .utf8) {</p><p class="text-idt25" data-id="312">do {</p><p class="text-idt25" data-id="313">print(utf8Text)</p><p class="text-idt25" data-id="314">if utf8Text == ”1” {</p><p class="text-idt25" data-id="315">completionHandler(1)</p><p class="text-idt25" data-id="316">} else {</p><p class="text-idt25" data-id="317">completionHandler(0)</p><p class="text-idt25" data-id="318">}</p><p class="text-idt25" data-id="319">}</p><p class="text-idt25" data-id="320">}</p><p class="text-idt25" data-id="321">}</p><p class="text-idt25" data-id="322">}</p><p class="text-idt25" data-id="323">}</p><p class="text-idt25" data-id="324">// 获取病历</p><p class="text-idt25" data-id="325">func getRecords(name: String， completionHandler: @escaping (_ res: [[String: Any]]) -] Void) {</p><p class="text-idt25" data-id="326">DispatchQueue.global().async {</p><p class="text-idt25" data-id="327">let url = URL(string: ”http://localhost:5000/home/checkinfo”)?.appendingPathComponent(name)</p><p class="text-idt25" data-id="328">AF.request(url!.absoluteString，</p><p class="text-idt25" data-id="329">method: .get).responseJSON { response in</p><p class="text-idt25" data-id="330">if let data = response.data {</p><p class="text-idt25" data-id="331">do {</p><p class="text-idt25" data-id="332">if let res = try JSONSerialization.jsonObject(with: data， options: []) as? [[String: Any]] {</p><p class="text-idt25" data-id="333">// 把数据传输给VC</p><p class="text-idt25" data-id="334">completionHandler(res)</p><p class="text-idt25" data-id="335">}</p><p class="text-idt25" data-id="336">} catch let error as NSError {</p><p class="text-idt25" data-id="337">print(error)</p><p class="text-idt25" data-id="338">}</p><p class="text-idt25" data-id="339">}</p><p class="text-idt25" data-id="340">}</p><p class="text-idt25" data-id="341">}</p><p class="text-idt25" data-id="342">}</p><p class="text-idt25" data-id="343">// 新增病历</p><p class="text-idt25" data-id="344">func createNewRecords(name: String， record: Record， completionHandler: @escaping (_ res: [String: Any]) -] Void) {</p><p class="text-idt25" data-id="345">DispatchQueue.global().async {</p><p class="text-idt25" data-id="346">let url = URL(string: ”http://localhost:5000/home/edit”)?.appendingPathComponent(name)</p><p class="text-idt25" data-id="347">AF.request(url!.absoluteString，</p><p class="text-idt25" data-id="348">method: .post，</p><p class="text-idt25" data-id="349">parameters: self.encodeRecord(patientRecord: record)).responseJSON { response in</p><p class="text-idt25" data-id="350">if let data = response.data {</p><p class="text-idt25" data-id="351">do {</p><p class="text-idt25" data-id="352">let res = try JSONSerialization.jsonObject(with: data， options: []) as! [String: Any]</p><p class="text-idt25" data-id="353">// 把数据传输给VC</p><p class="text-idt25" data-id="354">completionHandler(res)</p><p class="text-idt25" data-id="355">} catch let error as NSError {</p><p class="text-idt25" data-id="356">print(error)</p><p class="text-idt25" data-id="357">}</p><p class="text-idt25" data-id="358">}</p><p class="text-idt25" data-id="359">}</p><p class="text-idt25" data-id="360">}</p><p class="text-idt25" data-id="361">}</p><p class="text-idt25" data-id="362">}</p><p class="text-idt25" data-id="363">上述是iOS客户端中一个核心的NetworkService类，主要用于网络通信，负责与系统后台交互。通过注释可以看出，主要对用户注册、用户登录、获取医院信息、预约挂号、获取病历、新增病历等后台接口进行了二次封装。上述代码使用了 Alamofire框架，简化了 iOS中网络请求和结果回调的难度，在每一个接口内部都通过异步队列进行网络请求，防止阻塞主线程，保证 App的性能。</p><p class="text-idt25" data-id="364">4.3运行环境</p><p class="text-idt25" data-id="365">/</p><p class="text-idt25" data-id="366">图9 系统运行环境</p><p class="text-idt25" data-id="367">本系统的运行环境如下：</p><p class="text-idt25" data-id="368">操作系统：macOS Mojave 版本10.14.4</p><p class="text-idt25" data-id="369">处理器：2.2 GHz Intel Core i7</p><p class="text-idt25" data-id="370">内存：16GB 2400 MHz DDR4</p><p class="text-idt25" data-id="371">数据库：MongoDB</p><p class="text-idt25" data-id="372">以太坊客户端：Ganache</p><p class="text-idt25" data-id="373">4.4开发技术</p><p class="text-idt25" data-id="374">系统前端基于iOS平台，主要开发语言为Swift，主要使用了SnapKit、SwityJson、Alamofire等框架。系统后台基于 Node. js框架，通过 Ganache搭建本地私有以太坊区块链，利用 Solidity语言开发本系统的智能合约，通过 Web3. js开发库发布和运行智能合约，患者的非敏感信息存储在 MongoDB数据库。后台暴露API给iOS客户端调用，客户端和后台通过HTTP协议进行通信，数据格式为Json。</p><p class="text-idt25" data-id="375">4.4.1Solidity</p><p class="text-idt25" data-id="376">Solidity是一种面向对象的高级语言，用于实现智能合约。 智能合约是管理以太坊内账户行为的程序。Solidity受C++，Python和JavaScript的影响，旨在针对以太坊虚拟机（EVM）。Solidity是静态类型的，支持继承，库和复杂的用户定义类型以及其他功能。通过Solidity，可以创建智能合约，例如投票，众筹，盲目拍卖和多重签名钱包。</p><p class="text-idt25" data-id="377">4.4.2Swift</p><p class="text-idt25" data-id="378">Swift是2014年苹果公司在WWDC上发布的一中支持多编程范式、闭包、函数式编程的现代编程语言。Swift是一门集现代语言之大成，集结了苹果的工程师文化精髓以及开源社区多样化于一身的编程语言。编译器为专为性能所调优，语言专为开发所优化，二者绝不互相妥协。Swift代码为大部分现代硬件编译和优化，语法和基本库都基于指导原则设计。 Swift最大的优点就是在做到安全的同时又保证了速度，摒弃了 Objective- C动态性的缺点，增加了许多静态的类型判断，保证了代码安全，是一款适合用于工业开发的编程语言。</p><p class="text-idt25" data-id="379">4.4.3Ganache</p><p class="text-idt25" data-id="380">Ganache是以太坊开发的个人区块链，可用于部署合同，开发应用程序和运行测试。它既可用作桌面应用程序，也可用作命令行工具（以前称为TestRPC）。Ganache适用于Windows，Mac和Linux。</p><p class="text-idt25" data-id="381">4.4.4Web3.js</p><p class="text-idt25" data-id="382">web3.js是一个库集合，允许开发者使用HTTP，WebSocket或IPC连接与本地或远程以太坊节点进行交互。</p><p class="text-idt25" data-id="383">4.5 数据库表结构</p><p class="text-idt25" data-id="384">系统后台涉及到两张数据库表，分别是患者信息表和病历表，表结构如下：</p><p class="text-idt25" data-id="385">表1患者信息表（patientInformation）</p><p class="text-idt25" data-id="386">列名（字段）</p><p class="text-idt25" data-id="387">解释</p><p class="text-idt25" data-id="388">数据类型</p><p class="text-idt25" data-id="389">id</p><p class="text-idt25" data-id="390">患者ID</p><p class="text-idt25" data-id="391">String</p><p class="text-idt25" data-id="392">userame</p><p class="text-idt25" data-id="393">患者登陆名</p><p class="text-idt25" data-id="394">String</p><p class="text-idt25" data-id="395">name</p><p class="text-idt25" data-id="396">患者名字</p><p class="text-idt25" data-id="397">String</p><p class="text-idt25" data-id="398">gender</p><p class="text-idt25" data-id="399">患者性别</p><p class="text-idt25" data-id="400">String</p><p class="text-idt25" data-id="401">表2病历表（medicalRecord）</p><p class="text-idt25" data-id="402">列名（字段）</p><p class="text-idt25" data-id="403">解释</p><p class="text-idt25" data-id="404">数据类型</p><p class="text-idt25" data-id="405">record_id</p><p class="text-idt25" data-id="406">病历ID</p><p class="text-idt25" data-id="407">String</p><p class="text-idt25" data-id="408">patient_id</p><p class="text-idt25" data-id="409">患者ID</p><p class="text-idt25" data-id="410">String</p><p class="text-idt25" data-id="411">patient_name</p><p class="text-idt25" data-id="412">患者名字</p><p class="text-idt25" data-id="413">String</p><p class="text-idt25" data-id="414">patient_gender</p><p class="text-idt25" data-id="415">患者性别</p><p class="text-idt25" data-id="416">String</p><p class="text-idt25" data-id="417">patient_record</p><p class="text-idt25" data-id="418">病历内容</p><p class="text-idt25" data-id="419">String</p><p class="text-idt25" data-id="420">4.6系统演示</p><p class="text-idt25" data-id="421">本系统后台通过Node.js搭建，其中以太坊采用本地Ganache客户端，数据库采用Mongodb，利用Web3.js与智能合约进行交互。</p><p class="text-idt25" data-id="422">本系统前端采用iOS平台开发，命名为医疗助手App。主要的系统界面包括：登录/注册界面、患者个人主页、医生个人主页、患者查看个人病历、患者预约挂号、医生问诊主页、医生撰写病历页面等。</p><p class="text-idt25" data-id="423">4.6.1 启动Node.js服务器</p><p class="text-idt25" data-id="424">/</p><p class="text-idt25" data-id="425">图10 启动Node.js服务器</p><p class="text-idt25" data-id="426">通过npm start命令启动Node.js服务器。Node.js会启动一个监听本地5000端口的Web服务器。</p><p class="text-idt25" data-id="427">4.6.2 启动Mongodb数据库</p><p class="text-idt25" data-id="428">1）通过本地配置在终端前台启动Mongodb</p><p class="text-idt25" data-id="429">mongod --config /usr/local/etc/mongod.conf</p><p class="text-idt25" data-id="430">2）将Mongodb数据库设置为守护进程</p><p class="text-idt25" data-id="431">brew services start mongodb-community@4.0</p><p class="text-idt25" data-id="432">本文采用第二种方式，启动后输入mongo出现以下界面表示Mongodb成功启动：</p><p class="text-idt25" data-id="433">/</p><p class="text-idt25" data-id="434">图12 启动Mongodb数据库</p><p class="text-idt25" data-id="435">4.6.3 启动Ganache客户端</p><p class="text-idt25" data-id="436">Ganache是一个用来快速启动个人区块链的本地客户端，方便程序员用来本地测试智能合约的代码。打开Ganache客户端：</p><p class="text-idt25" data-id="437">/</p><p class="text-idt25" data-id="438">图13 Ganache客户端</p><p class="text-idt25" data-id="439">选择已经搭建好的spiffy-ornament环境，启动后如下：</p><p class="text-idt25" data-id="440">/</p><p class="text-idt25" data-id="441">图14 以太坊账户信息</p><p class="text-idt25" data-id="442">Ganache通过图形化的界面为我们显示现在已有的以太坊账户、已经创建的区块链、已经存在的交易信息和创建好的智能合约等信息。</p><p class="text-idt25" data-id="443">/</p><p class="text-idt25" data-id="444">图15 以太坊默认账户</p><p class="text-idt25" data-id="445">Ganache默认为我们创建好若干个账户，每个账户拥有1000个虚拟以太币。</p><p class="text-idt25" data-id="446">/</p><p class="text-idt25" data-id="447">图16 Ganache初始区块</p><p class="text-idt25" data-id="448">Ganache已经事先创建好若干个初始区块，开发者编写的智能合约的数据都会存储在这条区块链上。</p><p class="text-idt25" data-id="449">/</p><p class="text-idt25" data-id="450">图17 Ganache查看历史交易信息</p><p class="text-idt25" data-id="451">Ganache中也可以查看已经产生的历史交易信息，可以查看到每次交易的hash值、发送者的地址、接受者的地址以及每一次交易消耗的gas总额。后台配置到此全部开启成功，下面演示医疗助手App。</p><p class="text-idt25" data-id="452">4.6.3登录/注册</p><p class="text-idt25" data-id="453">登录/注册界面可以选择以患者身份登录还是以医生身份登录：</p><p class="text-idt25" data-id="454">/</p><p class="text-idt25" data-id="455">图18登录/注册页面</p><p class="text-idt25" data-id="456">4.6.4个人首页</p><p class="text-idt25" data-id="457">/</p><p class="text-idt25" data-id="458">图19患者个人首页</p><p class="text-idt25" data-id="459">/</p><p class="text-idt25" data-id="460">图20医生个人首页</p><p class="text-idt25" data-id="461">4.6.5患者查看历史病历</p><p class="text-idt25" data-id="462">患者点击查看病历后可以看到自己的历史病历信息，包括就诊的医院名称、医生名称和就诊的时间：</p><p class="text-idt25" data-id="463">/</p><p class="text-idt25" data-id="464">图21患者个人病历</p><p class="text-idt25" data-id="465">4.6.6病历详情</p><p class="text-idt25" data-id="466">查看某一次的病历详情：</p><p class="text-idt25" data-id="467">/</p><p class="text-idt25" data-id="468">图22 病历详情</p><p class="text-idt25" data-id="469">病历详情中可以查看到这张病历存放的智能合约的地址，还有就诊的医院的名称、医生名称、病历的创建时间和医生的诊断结果。</p><p class="text-idt25" data-id="470">4.6.7预约挂号</p><p class="text-idt25" data-id="471">患者点击预约挂号后， App会显示目前已经注册了的医院的信息，患者可以根据自己的需要授权某家医院，医院拿到患者的授权后，医院下注册的医生就拥有了查看患者病历信息和给患者编写病历的权限。</p><p class="text-idt25" data-id="472">/</p><p class="text-idt25" data-id="473">图23预约挂号页面</p><p class="text-idt25" data-id="474">给汕头附一医院授权，若授权成功，App会提示授权成功，反之提示授权失败：</p><p class="text-idt25" data-id="475">/</p><p class="text-idt25" data-id="476">图24患者预约挂号</p><p class="text-idt25" data-id="477">4.6.8医生问诊</p><p class="text-idt25" data-id="478">医生点击“我要问诊”进入问诊页面：</p><p class="text-idt25" data-id="479">/</p><p class="text-idt25" data-id="480">图25医生问诊页面</p><p class="text-idt25" data-id="481">App上方有一个搜索框，通过输入患者的名称，医生可以查看到患者的历史病历信息：</p><p class="text-idt25" data-id="482">/</p><p class="text-idt25" data-id="483">图26查看患者病历</p><p class="text-idt25" data-id="484">医生点击某一行的病历信息可以查看到患者以前的就诊信息，包括之前就诊的医院、就诊医生的姓名、就诊时间和以前医生开的处方等信息。</p><p class="text-idt25" data-id="485">4.6.9新建病历</p><p class="text-idt25" data-id="486">医生对患者问诊结束后，点击新增按钮可以给患者新建一份病历，写入此次诊断证明：</p><p class="text-idt25" data-id="487">/</p><p class="text-idt25" data-id="488">图27新建病历页面</p><p class="text-idt25" data-id="489">医生需要填写自己的姓名、所在医院及科室、诊断治疗的时间以及诊断结果和开设的处方信息。医生写入新的病历后，病历会写入到患者拥有的以太坊智能合约内，再次刷新App就可以看到刚才写入的新的病历信息。</p><p class="text-idt25" data-id="490">/</p><p class="text-idt25" data-id="491">图28 查看新建病历</p><p class="text-idt25" data-id="492">4.6.10写入验证</p><p class="text-idt25" data-id="493">医生新增一份电子病历，病历会实时写入到以太坊的区块链中，查看以太坊的回调信息：</p><p class="text-idt25" data-id="494">[</p><p class="text-idt25" data-id="495">{</p><p class="text-idt25" data-id="496">”to” : ”0xbb98aa07736d72ba94381f53c96ebc345f09caa9”，</p><p class="text-idt25" data-id="497">”s” :”0 x50 ca5 c645 d5 ce9 c6 a53 e284 bc3028 bc4 d73571 ab0208319 a6 c9 d7375994 f239 f”，</p><p class="text-idt25" data-id="498">”logsBloom” : ”0x00000000000000000000000000000000000000000000000000800000000020000000000000000000000000000000400000000000000000000000000010000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000”，</p><p class="text-idt25" data-id="499">”v” : ”0x1b”，</p><p class="text-idt25" data-id="500">”blockHash” :”0 x5 f6 a71548 c464293051 eaca8 d167229538 b36286 a6 e06 b7 d39 f2 ac02 c596 fc6 a”，</p><p class="text-idt25" data-id="501">”gasUsed” : 407109，</p><p class="text-idt25" data-id="502">”blockNumber” : 28，</p><p class="text-idt25" data-id="503">”from” : ”0xa0ba4385d1020f6c5869fa51e2435f368ae8eefe”，</p><p class="text-idt25" data-id="504">”r” : ”0xc6164677f781f14e4dff217bd139961040cdf9fcb78b2ff5e9dcb167a353e8cc”，</p><p class="text-idt25" data-id="505">”transactionIndex” : 0，</p><p class="text-idt25" data-id="506">”events” : {</p><p class="text-idt25" data-id="507">”makeChange” : {</p><p class="text-idt25" data-id="508">”transactionIndex” : 0，</p><p class="text-idt25" data-id="509">”event” : ”makeChange”，</p><p class="text-idt25" data-id="510">”signature” :”0 x1 c5 c01 d25862 c15354 d25454 df5 e17517 eb4 b9328 fc0 d52846 b007332 ef38 cc8”，</p><p class="text-idt25" data-id="511">”blockNumber” : 28，</p><p class="text-idt25" data-id="512">”transactionHash” : ”0x3cb590390544fc25f20a224ba9351b0b66fc032f603efa18f79453661fbfb4cb”，</p><p class="text-idt25" data-id="513">”blockHash” :”0 x5 f6 a71548 c464293051 eaca8 d167229538 b36286 a6 e06 b7 d39 f2 ac02 c596 fc6 a”，</p><p class="text-idt25" data-id="514">”type” : ”mined”，</p><p class="text-idt25" data-id="515">”returnValues” : {</p><p class="text-idt25" data-id="516">”_a” : ”0xa0BA4385d1020f6c5869fA51E2435F368ae8EeFe”，</p><p class="text-idt25" data-id="517">”0” : ”0xa0BA4385d1020f6c5869fA51E2435F368ae8EeFe”</p><p class="text-idt25" data-id="518">}，</p><p class="text-idt25" data-id="519">”logIndex” : 0，</p><p class="text-idt25" data-id="520">”raw” : {</p><p class="text-idt25" data-id="521">”data” : ”0x000000000000000000000000a0ba4385d1020f6c5869fa51e2435f368ae8eefe”，</p><p class="text-idt25" data-id="522">”topics” : [</p><p class="text-idt25" data-id="523">”0 x1 c5 c01 d25862 c15354 d25454 df5 e17517 eb4 b9328 fc0 d52846 b007332 ef38 cc8”</p><p class="text-idt25" data-id="524">]</p><p class="text-idt25" data-id="525">}，</p><p class="text-idt25" data-id="526">”id” : ”log_0x2562de00048c49c4ebbfbe2fb87618a9dfee8d79cd9c4bca83730dae12526fd3”，</p><p class="text-idt25" data-id="527">”address” : ”0xbB98AA07736d72ba94381F53C96EBc345f09CAa9”</p><p class="text-idt25" data-id="528">}</p><p class="text-idt25" data-id="529">}，</p><p class="text-idt25" data-id="530">”transactionHash” : ”0x3cb590390544fc25f20a224ba9351b0b66fc032f603efa18f79453661fbfb4cb”，</p><p class="text-idt25" data-id="531">”status” : true，</p><p class="text-idt25" data-id="532">”contractAddress” : null，</p><p class="text-idt25" data-id="533">”cumulativeGasUsed” : 407109</p><p class="text-idt25" data-id="534">}</p><p class="text-idt25" data-id="535">]</p><p class="text-idt25" data-id="536">从上述回调中可以看出，新建的电子病历写入到了地址为0 xbb98 aa07736 d72 ba94381 f53 c96 ebc345 f09 caa9的合约账户中，</p><p class="text-idt25" data-id="537">写入的区块链的Hash值为：</p><p class="text-idt25" data-id="538">0 x5 f6 a71548 c464293051 eaca8 d167229538 b36286 a6 e06 b7 d39 f2 ac02 c596 fc6 a</p><p class="text-idt25" data-id="539">本次写入用了407109个Gas，区块链的序列号为28。综上，实验结果符合预期。</p><p class="text-idt25" data-id="540">5.问题与解决办法</p><p class="text-idt25" data-id="541">5.1遇到的问题</p><p class="text-idt25" data-id="542">首先，区块链技术是比较新颖的一门技术，在对其开发前我们需要先了解其基本原理、工作机制。刚开始学习区块链时遇到的比较大的困难对共识机制的了解，共识机制指的是在分布式的环境下多个节点如何达成共识，在比特币中主要应用了工作量证明( Proof- of- Work)的方法。除此之外，对于时间戳服务器、双重支付的问题的理解也十分关键。</p><p class="text-idt25" data-id="543">系统设计采用以太坊作为开发平台，以太坊是一个生态圈，含有许多的开发工具和开发框架。其中最重要的是Solidity语言，Solidity语言用来开发以太坊智能合约的语言，掌握其语法与特性十分重要。其次遇到的困难是学习Truffle框架，Truffle框架是一款以太坊的开发框架，帮助开发者优化了智能合约的编译、发布、交易等流程。Truffle框架还包含了一系列的子框架，包括：Truffle-Contract等。除此之外，对于 Ganache等以太坊客户端的学习也十分困难，开发者要访问以太坊区块链必须通过相关客户端提供的 API，有官方提供的 Go语言客户端还有方便本地使用的 Ganache客户端。其次，比较困难的是对于Web3.js库的学习，Web3.js库是一个封装了访问区块链相关API的JavaScrtpt库。简单来说，Web3.js是前端界面与区块链智能合约的桥梁，对于项目的搭建十分重要。</p><p class="text-idt25" data-id="544">5.2解决办法</p><p class="text-idt25" data-id="545">接触一个新的领域，或者接触一门新的技术，都需要花大量的时间去熟悉才能掌握。特别是对于Solidity语言、Truffle框架、Web3.js库，国内非常少中文资源，最好的学习资料是官方文档。通过查阅官方文档，学习官方文档里的Demo，可以快速的入门。除了官方文档，Github上有非常优秀的开源项目，通过学习前人的代码，可以掌握高质量的开发技巧。</p><p class="text-idt25" data-id="546">5.3开发技巧</p><p class="text-idt25" data-id="547">本系统的开发主要包括两方面：前端界面的开发和后台以太坊区块链的开发。合理的利用Truffle框架可以帮助开发者一键搭建项目，包括智能合约、前端项目、编译模块和服务器脚本。前端开发要注意与以太坊的接口对接，常见的可以通过 Web3. js或者 Truffle- contract库进行读取智能合约的示例，从而获取智能合约的数据和调用智能合约的函数。以太坊的开发则要合理利用 Ganache工具，在本地搭建私有的区块链作为测试，可以迅速的返回结果，不需要等待出块的时间，方便开发者进行测试和开发。</p><p class="text-idt25" data-id="548">6.总结与展望</p><p class="text-idt25" data-id="549">6.1总结</p><p class="text-idt25" data-id="550">本文提出了一个利用区块链特性设计的电子病历安全存储方案，还提出了一个利用智能合约实现的授权共享算法。此外，编码设计了一个基于 iOS平台和以太坊平台的医疗助手 App，该系统前端通过 iOS平台实现了问诊和就诊的流程，后台通过以太坊平台来存储患者的电子病历信息和管理电子病历的访问控制权限。</p><p class="text-idt25" data-id="551">6.2展望</p><p class="text-idt25" data-id="552">本文介绍的基于以太坊的电子病历管理和共享系统还存在许多的不足和缺陷。一方面由于本文通过本地 Ganache客户端搭建的本地私有链是免费的，但是如果大规模商业化，需要去以太坊平台注册相关密钥和信息，而以太坊需要收费，因为成本是非常大的一个考量。其次，以太坊是基于区块链设计的去中心化的分布式数据库，本身需要消耗大量的计算资源和电力资源，因此从资源利用的方面考虑，以太坊方案也有它天生的不足。最后，区块链中共识机制的达成需要相关算法的支持，而在以太坊中采用的权益证明（ Proof- of- Stake， PoS，又译持有量证明）需要多个节点达成共识，实时性不高，如果将本系统大规模的应用在医疗系统中，系统的响应速度和 Qps也许会成为最大的瓶颈。</p><p class="text-idt25" data-id="553">综上所述，以太坊有着其天生的去中心化、不可篡改和匿名性的优点，但同时也具有收费高、资源消耗大、实时性低等缺点，综合以太坊平台的优点和缺点，本文认为可以将患者比较重要的医疗隐私信息通过以太坊平台存储，而与医疗敏感数据无关的个人信息等数据存储在相关机构的数据库即可。</p><p class="text-idt25" data-id="554">6.3致谢</p><p class="text-idt25" data-id="555">牛顿曾经说过：”我之所以能取得现在的成就，是因为我站在巨人的肩膀上”。同理，没有老师、同学、师兄和亲人的支持和鼓励，本文也难以如此快的完成。首先，我要感谢我的导师朱诗生老师，朱师生老师从毕业设计的选题、毕业设计的设计、毕业设计的中期进展到最终毕业论文的修改，都给予了本人偌大的帮助和指导。再次对朱老师对我的帮助和关怀表示诚挚的谢意！其次，还要感谢黄仁俊师兄，黄仁俊师兄利用自己的空余时间给我们讲解区块链的相关知识，以及目前关于区块链的发展情况，还将自己平时收集的资源无私的奉献给我们，对我论文的研究方向给出了许多意见和指导，对黄仁俊师兄表示诚挚的感谢！此外，我还要感谢我的搭档梁汉帮同学，梁汉帮同学对于以太坊平台和 Web3. js等框架有深刻的见解，在 Node. js方面也有着深厚的编程功力，在他的协助写系统才能顺利的完成。最后，我要感谢我的父母，是他们的支持让我能一直坚持学习、坚持自己的研究方向，再次衷心感谢他们！</p><p class="text-idt25" data-id="556">参考文献：</p><p class="text-idt25" data-id="557">[1] 梅颖. 安全存储医疗记录的区块链方法研究[J]. 江西师范大学学报(自然科学版)，2017，41(5):484-490.</p><p class="text-idt25" data-id="558">[2]曹敏姿，张琳琳，毕雪华，赵楷.个性化(α， l)-多样性 k-匿名隐私保护模型[ J].计算机科学，2018，45(11).</p><p class="text-idt25" data-id="559">[3] 张亮，刘百祥，张如意，江斌鑫，刘一江.区块链技术综述[J/OL].计算机工程:1-15[2019-04-17].http://kns.cnki.net/kcms/detail/31.1289.TP.20190316.1352.002.html.</p><p class="text-idt25" data-id="560">[4] 赵延红，原宝华，梁军.区块链技术在医疗领域中的应用探讨[J].中国医学教育技术，2018，32(01):1-7.</p><p class="text-idt25" data-id="561">[5] Nakamoto S. Bitcoin: a peer-to-peer electronic cash system [Online]， available: http://bitcoin.org/bitcoin.pdf， June 12， 2016</p><p class="text-idt25" data-id="562">[6] 薛腾飞，傅群超，王枞，王新宴.基于区块链的医疗数据共享模型研究[J].自动化学报，2017，43(09):1555-1562.</p><p class="text-idt25" data-id="563">[7] 袁勇，王飞跃.区块链技术发展现状与展望[J].自动化学报，2016，42(04):481-494.</p><p class="text-idt25" data-id="564">[8] 邱欣欣，马兆丰，徐明昆.以太坊智能合约安全漏洞分析及对策[J].信息安全与通信保密，2019(02):44-53.</p><p class="text-idt25" data-id="565">[9]邵奇峰，金澈清，张召，钱卫宁，周傲英.区块链技术:架构及进展[J].计算机学报，2018，41(05):969-988.</p><p class="text-idt25" data-id="566">[10]徐健，陈志德，龚平，王可可.基于区块链网络的医疗记录安全储存访问方案[J/OL].计算机应用:1-8[2019-04-27].http://kns.cnki.net/kcms/detail/51.1307.TP.20190121.1013.058.html.</p>        <div class="paper-footer">
            <p>检测报告由<a href="http://www.paperpass.com/" target="_black">PaperPass</a>文献相似度检测系统生成</p>
            <p>Copyright © 2007-2019 PaperPass</p>
        </div>
    </div>

</div>
</body>
<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/Lib.js"></script>
<script type="text/javascript">
    Report.report_id = '5cc5edc55924bzmd7';
</script>
<script type="text/javascript">
    (function(System,$){
        var cache = new System.Cache(System.report_id,localStorage);
        $(function(){
            $.each(cache.get(),function(){
                $('[data-id='+this.id+']').addClass('g-font-color green').html(this.text);
            });

        });
    })(Report,jQuery);

</script>
</html>
